<script>
    const game = document.getElementById('game');
    const pacman = document.getElementById('pacman');
    const levelDisplay = document.getElementById('level-display');
    const scoreDisplay = document.getElementById('score-display');

    // Récupérer les valeurs du CSS pour un calcul exact
    const size = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-size')); // 20
    const pacmanSize = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--pacman-size')); // 18
    const offset = (size - pacmanSize) / 2; // 1

    const gridCols = 20;
    const gridRows = 20;
    
    let grid = [];
    let maze = [];
    let pac = {row:1, col:1, direction: 'right'};
    let currentLevel = 1;
    let score = 0;
    let dotsRemaining = 0;

    // --- 1. Logique de Progression de Niveau ---

    function nextLevel() {
        currentLevel++;
        levelDisplay.textContent = `Niveau: ${currentLevel}`;
        initGame();
    }

    function checkWinCondition() {
        if (dotsRemaining === 0) {
            setTimeout(nextLevel, 500);
        }
    }


    // --- 2. Génération Aléatoire du Labyrinthe (DFS) ---
    function createEmptyMaze() {
        const tempMaze = [];
        for (let r = 0; r < gridRows; r++) {
            tempMaze[r] = [];
            for (let c = 0; c < gridCols; c++) {
                tempMaze[r][c] = 1;
            }
        }
        return tempMaze;
    }

    function generateRandomMaze() {
        maze = createEmptyMaze();
        const stack = [];
        const startR = 1;
        const startC = 1;
        
        stack.push({ r: startR, c: startC });
        maze[startR][startC] = 0;

        while (stack.length > 0) {
            const current = stack.pop();
            const { r, c } = current;
            
            const directions = [
                { dr: -2, dc: 0 }, { dr: 2, dc: 0 }, 
                { dr: 0, dc: -2 }, { dr: 0, dc: 2 }
            ];
            
            directions.sort(() => Math.random() - 0.5);

            for (const dir of directions) {
                const nextR = r + dir.dr;
                const nextC = c + dir.dc;

                if (nextR > 0 && nextR < gridRows - 1 && nextC > 0 && nextC < gridCols - 1 && maze[nextR][nextC] === 1) {
                    const wallR = r + dir.dr / 2;
                    const wallC = c + dir.dc / 2;
                    maze[wallR][wallC] = 0;
                    maze[nextR][nextC] = 0;
                    
                    stack.push(current); 
                    stack.push({ r: nextR, c: nextC });
                    break;
                }
            }
        }
    }
    
    function drawMaze() {
        game.innerHTML = ''; // C'est OK car Pac-Man n'est plus un enfant de #game
        grid.length = 0;
        dotsRemaining = 0;

        for(let r=0;r<gridRows;r++){
            for(let c=0;c<gridCols;c++){
                if(maze[r][c] === 0){
                    maze[r][c] = 2; 
                    dotsRemaining++;
                }
            }
        }
        
        maze[pac.row][pac.col] = 0;
        dotsRemaining--;

        for(let r=0;r<gridRows;r++){
            for(let c=0;c<gridCols;c++){
                const cell = document.createElement('div');
                if(maze[r][c]===1) cell.className='wall';
                else if(maze[r][c]===2){
                    cell.className='dot-container';
                    const dot = document.createElement('div');
                    dot.className='dot';
                    cell.appendChild(dot);
                }
                game.appendChild(cell);
                grid.push({row:r,col:c,type:maze[r][c],el:cell});
            }
        }
    }

    // --- 3. Contrôles et Mouvement (avec Correction de Position Fiable) ---

    function updatePacmanPosition() {
        pacman.style.left = (pac.col * size + offset) + 'px'; 
        pacman.style.top = (pac.row * size + offset) + 'px';
    }

    function setPacmanRotation(dir) {
        let rotation = 0;
        if (dir === 'right') rotation = 0;
        else if (dir === 'down') rotation = 90;
        else if (dir === 'left') rotation = 180;
        else if (dir === 'up') rotation = 270;

        pacman.style.transform = `rotate(${rotation}deg)`;
    }
    
    let isListenerActive = false; 

    function handleKeyDown(e) {
        let newRow = pac.row;
        let newCol = pac.col;
        let newDir = pac.direction;

        if(e.key==='ArrowUp'){ newRow--; newDir='up'; }
        else if(e.key==='ArrowDown'){ newRow++; newDir='down'; }
        else if(e.key==='ArrowLeft'){ newCol--; newDir='left'; }
        else if(e.key==='ArrowRight'){ newCol++; newDir='right'; }

        if (newDir !== pac.direction) {
            pac.direction = newDir;
            setPacmanRotation(pac.direction);
        }

        if(newRow>=0 && newRow<gridRows && newCol>=0 && newCol<gridCols && maze[newRow][newCol]!==1){
            
            pac.row=newRow; pac.col=newCol;
            updatePacmanPosition();

            const idx = newRow*gridCols+newCol;
            if(grid[idx].type===2){
                score += 10; 
                dotsRemaining--;
                scoreDisplay.textContent = `Score: ${score}`;

                // --- C'est ici qu'étaient les caractères 'Â' et '_' ---
                grid[idx].type=0; 
                maze[newRow][newCol] = 0; 
                grid[idx].el.innerHTML=''; 

                checkWinCondition();
            }
        }
    }

    // --- 4. Fonction d'Initialisation Globale ---

    function initGame() {
        // 1. Générer le nouveau labyrinthe et le dessiner
        generateRandomMaze();
        drawMaze();

        // 2. Réinitialiser la position et l'apparence de Pac-Man
        pac.row = 1;
        pac.col = 1;
        pac.direction = 'right';
        updatePacmanPosition();
        setPacmanRotation(pac.direction);
        
        // 3. Activer les écouteurs si ce n'est pas déjà fait
        if (!isListenerActive) {
            document.addEventListener('keydown', handleKeyDown);
            isListenerActive = true;
        }
    }

    // Démarrer le jeu
    initGame(); 
</script>

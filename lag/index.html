<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pac-Man G√©n√©ration Al√©atoire & Position Corrig√©e</title>
<style>
    /* Styles de base et du corps */
    body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background: #0d0d0d;
        font-family: 'Arial', sans-serif;
        color: #fff;
    }
    
    /* Conteneur du jeu */
    #game {
        position: relative;
        width: 400px;
        height: 400px;
        background: #000;
        display: grid;
        grid-template-columns: repeat(20, 20px);
        grid-template-rows: repeat(20, 20px);
        border: 4px solid #00FFFF;
        box-shadow: 0 0 20px #00FFFF, inset 0 0 10px #00FFFF;
        /* Correction : Ajout de box-sizing pour que la bordure ne compte pas dans la taille */
        box-sizing: content-box; 
    }
    
    /* Murs üß± - √âpais et stylis√©s */
    .wall {
        background: #0000AA;
        border: 1px solid #0000FF;
        box-shadow: inset 0 0 8px #0000FF, 0 0 5px #0000FF;
    }

    /* Points (Pac-Dots) üü° - Plus brillants */
    .dot-container {
        display: flex;
        justify-content: center;
        align-items: center;
    }
    .dot {
        width: 8px;
        height: 8px;
        background: #FFFF00;
        border-radius: 50%;
        box-shadow: 0 0 10px #FFFF00, 0 0 20px #FFD700;
        animation: pulse 1.5s infinite alternate;
    }

    /* Pac-Man üòã - La star du jeu */
    #pacman {
        position: absolute;
        width: 18px;
        height: 18px;
        background: #FFD700;
        border-radius: 50%;
        z-index: 10;
        transition: left 0.1s linear, top 0.1s linear, transform 0.1s;
        box-shadow: 0 0 15px #FFD700;
        
        /* Forme de bouche utilisant clip-path */
        clip-path: polygon(100% 0, 100% 50%, 75% 50%, 100% 100%, 0 100%, 0 0);
        animation: chomp 0.2s infinite step-end;
        transform-origin: center;

        /* CORRECTION: On enl√®ve les d√©calages fixes du CSS */
        /* left: 1px; top: 1px; */ 
    }

    /* Keyframes pour les animations */
    @keyframes chomp {
        0% { clip-path: polygon(100% 0, 100% 50%, 75% 50%, 100% 100%, 0 100%, 0 0); }
        50% { clip-path: circle(50% at 50% 50%); }
    }
    
    @keyframes pulse {
        from { opacity: 0.8; transform: scale(1); }
        to { opacity: 1; transform: scale(1.1); }
    }
</style>
</head>
<body>
<div id="game"></div>
<div id="pacman"></div>

<script>
    const game = document.getElementById('game');
    const pacman = document.getElementById('pacman');
    const size = 20; // Taille cellule (20x20px)
    const pacmanSize = 18; // Taille de Pac-Man (18x18px)
    const offset = (size - pacmanSize) / 2; // D√©calage pour centrer (20 - 18) / 2 = 1px
    
    const gridCols = 20;
    const gridRows = 20;
    const grid = [];
    let maze = [];

    // --- 1. G√©n√©ration Al√©atoire du Labyrinthe (DFS) ---
    function createEmptyMaze() {
        const tempMaze = [];
        for (let r = 0; r < gridRows; r++) {
            tempMaze[r] = [];
            for (let c = 0; c < gridCols; c++) {
                tempMaze[r][c] = 1; // 1 = Mur
            }
        }
        return tempMaze;
    }

    function generateRandomMaze() {
        maze = createEmptyMaze();
        const stack = [];
        const startR = 1;
        const startC = 1;
        
        stack.push({ r: startR, c: startC });
        maze[startR][startC] = 0; // 0 = Chemin

        while (stack.length > 0) {
            const current = stack.pop();
            const { r, c } = current;
            
            const directions = [
                { dr: -2, dc: 0 }, { dr: 2, dc: 0 }, 
                { dr: 0, dc: -2 }, { dr: 0, dc: 2 }
            ];
            
            directions.sort(() => Math.random() - 0.5);

            for (const dir of directions) {
                const nextR = r + dir.dr;
                const nextC = c + dir.dc;

                if (nextR > 0 && nextR < gridRows - 1 && nextC > 0 && nextC < gridCols - 1 && maze[nextR][nextC] === 1) {
                    const wallR = r + dir.dr / 2;
                    const wallC = c + dir.dc / 2;
                    maze[wallR][wallC] = 0;
                    maze[nextR][nextC] = 0;
                    
                    stack.push(current); 
                    stack.push({ r: nextR, c: nextC });
                    break;
                }
            }
        }
    }
    
    // --- 2. Initialisation du Jeu ---
    generateRandomMaze();
    
    // Ajout des points (Pac-Dots) dans tous les chemins (0)
    for(let r=0;r<gridRows;r++){
        for(let c=0;c<gridCols;c++){
            if(maze[r][c] === 0){
                 maze[r][c] = 2; // 2 = Point
            }
        }
    }
    
    // S'assurer que le point de d√©part est vide (pas de dot)
    maze[1][1] = 0; 

    // Position initiale de Pac-Man
    let pac = {row:1, col:1, direction: 'right'};

    /**
     * Dessine le labyrinthe dans le DOM √† partir de la matrice `maze`.
     */
    function drawMaze() {
        game.innerHTML = '';
        grid.length = 0;
        
        for(let r=0;r<gridRows;r++){
            for(let c=0;c<gridCols;c++){
                const cell = document.createElement('div');
                if(maze[r][c]===1) cell.className='wall';
                else if(maze[r][c]===2){
                    cell.className='dot-container';
                    const dot = document.createElement('div');
                    dot.className='dot';
                    cell.appendChild(dot);
                }
                game.appendChild(cell);
                grid.push({row:r,col:c,type:maze[r][c],el:cell});
            }
        }
    }
    
    drawMaze();

    /**
     * Calcule et applique la position de Pac-Man pour qu'il soit centr√©.
     * C'est ici qu'√©tait le bug !
     */
    function updatePacmanPosition() {
        // Le calcul correct pour centrer le 18x18 dans le 20x20
        // (Position de la colonne * Taille de la cellule) + D√©calage de centrage (1px)
        pacman.style.left = (pac.col * size + offset) + 'px'; 
        pacman.style.top = (pac.row * size + offset) + 'px';
    }

    updatePacmanPosition(); // Positionnement initial

    /**
     * Applique la rotation de Pac-Man en fonction de sa direction
     */
    function setPacmanRotation(dir) {
        let rotation = 0;
        if (dir === 'right') rotation = 0;
        else if (dir === 'down') rotation = 90;
        else if (dir === 'left') rotation = 180;
        else if (dir === 'up') rotation = 270;

        pacman.style.transform = `rotate(${rotation}deg)`;
    }

    setPacmanRotation(pac.direction);

    // --- 3. Contr√¥les et Logique du Jeu ---

    document.addEventListener('keydown', e=>{
        let newRow = pac.row;
        let newCol = pac.col;
        let newDir = pac.direction;

        if(e.key==='ArrowUp'){ newRow--; newDir='up'; }
        else if(e.key==='ArrowDown'){ newRow++; newDir='down'; }
        else if(e.key==='ArrowLeft'){ newCol--; newDir='left'; }
        else if(e.key==='ArrowRight'){ newCol++; newDir='right'; }

        // Mettre √† jour la direction AVANT de d√©placer (pour rotation)
        if (newDir !== pac.direction) {
            pac.direction = newDir;
            setPacmanRotation(pac.direction);
        }

        // V√©rifier mur et limites
        if(newRow>=0 && newRow<gridRows && newCol>=0 && newCol<gridCols && maze[newRow][newCol]!==1){
            
            // D√©placer Pac-Man
            pac.row=newRow; pac.col=newCol;
            updatePacmanPosition(); // Appliquer la nouvelle position centr√©e

            // manger un point
            const idx = newRow*gridCols+newCol;
            if(grid[idx].type===2){
                grid[idx].type=0;
                maze[newRow][newCol] = 0;
                grid[idx].el.innerHTML='';
            }
        }
    });
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pac-Man G√©n√©ration Al√©atoire</title>
<style>
    /* Styles de base et du corps */
    body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background: #0d0d0d; /* Fond presque noir */
        font-family: 'Arial', sans-serif;
        color: #fff;
    }
    
    /* Conteneur du jeu */
    #game {
        position: relative;
        width: 400px;
        height: 400px;
        background: #000;
        display: grid;
        grid-template-columns: repeat(20, 20px);
        grid-template-rows: repeat(20, 20px);
        border: 4px solid #00FFFF; /* Bordure N√©on */
        box-shadow: 0 0 20px #00FFFF, inset 0 0 10px #00FFFF;
    }
    
    /* Murs üß± - √âpais et stylis√©s */
    .wall {
        background: #0000AA; /* Bleu plus fonc√© */
        border: 1px solid #0000FF; /* Contour */
        box-shadow: inset 0 0 8px #0000FF, 0 0 5px #0000FF; /* Effet N√©on interne */
    }

    /* Points (Pac-Dots) üü° - Plus brillants */
    .dot-container {
        display: flex; /* Pour centrer le point dans la cellule */
        justify-content: center;
        align-items: center;
    }
    .dot {
        width: 8px; /* Taille l√©g√®rement augment√©e */
        height: 8px;
        background: #FFFF00;
        border-radius: 50%;
        box-shadow: 0 0 10px #FFFF00, 0 0 20px #FFD700; /* Super effet de lueur */
        animation: pulse 1.5s infinite alternate; /* Ajout d'une petite animation de pulsation */
    }

    /* Pac-Man üòã - La star du jeu */
    #pacman {
        position: absolute;
        width: 18px;
        height: 18px;
        background: #FFD700; /* Or/Jaune plus riche */
        border-radius: 50%;
        z-index: 10;
        /* La transition pour la rotation est importante pour le look */
        transition: left 0.1s linear, top 0.1s linear, transform 0.1s;
        box-shadow: 0 0 15px #FFD700; /* Lueur Pac-Man */
        
        /* Forme de bouche utilisant clip-path */
        clip-path: polygon(100% 0, 100% 50%, 75% 50%, 100% 100%, 0 100%, 0 0);
        /* Animation de la bouche */
        animation: chomp 0.2s infinite step-end;
        transform-origin: center;
        /* Correction visuelle du d√©calage */
        left: 1px;
        top: 1px; 
    }

    /* Keyframes pour les animations */
    @keyframes chomp {
        0% { clip-path: polygon(100% 0, 100% 50%, 75% 50%, 100% 100%, 0 100%, 0 0); } /* Bouche ouverte */
        50% { clip-path: circle(50% at 50% 50%); } /* Bouche ferm√©e (cercle complet) */
    }
    
    @keyframes pulse {
        from { opacity: 0.8; transform: scale(1); }
        to { opacity: 1; transform: scale(1.1); }
    }
</style>
</head>
<body>
<div id="game"></div>
<div id="pacman"></div>

<script>
    const game = document.getElementById('game');
    const pacman = document.getElementById('pacman');
    const size = 20; // Taille cellule (20x20px)
    const gridCols = 20;
    const gridRows = 20;
    const grid = [];
    let maze = [];

    // --- 1. G√©n√©ration Al√©atoire du Labyrinthe (DFS) ---

    /**
     * Cr√©e une grille vide (tous des murs)
     * @returns {Array<Array<number>>} La grille (1 = mur)
     */
    function createEmptyMaze() {
        const tempMaze = [];
        for (let r = 0; r < gridRows; r++) {
            tempMaze[r] = [];
            for (let c = 0; c < gridCols; c++) {
                tempMaze[r][c] = 1; // 1 = Mur
            }
        }
        return tempMaze;
    }

    /**
     * G√©n√®re un labyrinthe al√©atoire en utilisant l'algorithme DFS.
     * Les chemins sont cr√©√©s aux coordonn√©es paires, les murs restent aux impaires.
     */
    function generateRandomMaze() {
        maze = createEmptyMaze();
        const stack = [];
        
        // D√©marrer au coin (1, 1) - doit √™tre impair
        const startR = 1;
        const startC = 1;
        
        stack.push({ r: startR, c: startC });
        maze[startR][startC] = 0; // 0 = Chemin

        while (stack.length > 0) {
            const current = stack.pop();
            const { r, c } = current;
            
            // Directions (haut, bas, gauche, droite)
            const directions = [
                { dr: -2, dc: 0 }, { dr: 2, dc: 0 }, 
                { dr: 0, dc: -2 }, { dr: 0, dc: 2 }
            ];
            
            // M√©langer les directions pour le c√¥t√© al√©atoire
            directions.sort(() => Math.random() - 0.5);

            for (const dir of directions) {
                const nextR = r + dir.dr;
                const nextC = c + dir.dc;

                // V√©rifier si la nouvelle cellule est dans les limites et non visit√©e (est toujours un mur)
                if (nextR > 0 && nextR < gridRows - 1 && nextC > 0 && nextC < gridCols - 1 && maze[nextR][nextC] === 1) {
                    // Supprimer le mur entre la cellule actuelle et la suivante
                    const wallR = r + dir.dr / 2;
                    const wallC = c + dir.dc / 2;
                    maze[wallR][wallC] = 0; // 0 = Chemin

                    // Marquer la prochaine cellule comme chemin
                    maze[nextR][nextC] = 0;
                    
                    // Remettre l'actuelle dans la pile (pour les autres voisins) et ajouter la nouvelle
                    stack.push(current); 
                    stack.push({ r: nextR, c: nextC });
                    break; // S'arr√™ter apr√®s avoir trouv√© un chemin pour le c√¥t√© "profondeur"
                }
            }
        }
    }
    
    // --- 2. Initialisation du Jeu ---

    generateRandomMaze();
    
    // Ajout des points (Pac-Dots) dans tous les chemins (0)
    for(let r=0;r<gridRows;r++){
        for(let c=0;c<gridCols;c++){
            if(maze[r][c] === 0){
                 maze[r][c] = 2; // 2 = Point
            }
        }
    }
    
    // S'assurer que le point de d√©part est vide (pas de dot)
    maze[1][1] = 0; 


    // Position initiale de Pac-Man
    let pac = {row:1, col:1, direction: 'right'};

    /**
     * Dessine le labyrinthe dans le DOM √† partir de la matrice `maze`.
     */
    function drawMaze() {
        game.innerHTML = ''; // Nettoyer l'ancienne grille
        grid.length = 0; // Vider l'ancienne grille JS
        
        for(let r=0;r<gridRows;r++){
            for(let c=0;c<gridCols;c++){
                const cell = document.createElement('div');
                if(maze[r][c]===1) cell.className='wall';
                else if(maze[r][c]===2){
                    cell.className='dot-container';
                    const dot = document.createElement('div');
                    dot.className='dot';
                    cell.appendChild(dot);
                }
                game.appendChild(cell);
                grid.push({row:r,col:c,type:maze[r][c],el:cell});
            }
        }
    }
    
    drawMaze(); // Dessiner la grille une fois qu'elle est g√©n√©r√©e et remplie de dots

    // Correction du bug : Positionner Pac-Man avec un l√©ger d√©calage pour le centrer parfaitement
    // (col * size + (size - width) / 2) -> (1*20 + (20-18)/2) = 21px
    function updatePacmanPosition() {
        // Le 1px ici compense les 1px de border/marge et centre mieux le 18x18 dans la case 20x20
        pacman.style.left = (pac.col * size) + 1 + 'px'; 
        pacman.style.top = (pac.row * size) + 1 + 'px';
    }

    updatePacmanPosition();

    /**
     * Applique la rotation de Pac-Man en fonction de sa direction
     * @param {string} dir - 'up', 'down', 'left', 'right'
     */
    function setPacmanRotation(dir) {
        let rotation = 0;
        if (dir === 'right') rotation = 0;
        else if (dir === 'down') rotation = 90;
        else if (dir === 'left') rotation = 180;
        else if (dir === 'up') rotation = 270;

        // On combine la rotation et l'animation de bouche
        pacman.style.transform = `rotate(${rotation}deg)`;
    }

    setPacmanRotation(pac.direction); // Initialiser la rotation

    // --- 3. Contr√¥les et Logique du Jeu ---

    document.addEventListener('keydown', e=>{
        let newRow = pac.row;
        let newCol = pac.col;
        let newDir = pac.direction;

        if(e.key==='ArrowUp'){ newRow--; newDir='up'; }
        else if(e.key==='ArrowDown'){ newRow++; newDir='down'; }
        else if(e.key==='ArrowLeft'){ newCol--; newDir='left'; }
        else if(e.key==='ArrowRight'){ newCol++; newDir='right'; }

        // Mettre √† jour la direction AVANT de d√©placer (pour rotation)
        if (newDir !== pac.direction) {
            pac.direction = newDir;
            setPacmanRotation(pac.direction);
        }

        // V√©rifier mur et limites
        if(newRow>=0 && newRow<gridRows && newCol>=0 && newCol<gridCols && maze[newRow][newCol]!==1){
            
            // D√©placer Pac-Man
            pac.row=newRow; pac.col=newCol;
            updatePacmanPosition(); // Appliquer la nouvelle position

            // manger un point
            const idx = newRow*gridCols+newCol;
            if(grid[idx].type===2){
                grid[idx].type=0; // Marquer la case comme vide
                maze[newRow][newCol] = 0; // Mettre √† jour la matrice
                grid[idx].el.innerHTML=''; // enlever dot visuellement
            }
        }
    });
</script>
</body>
</html>

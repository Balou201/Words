<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pac-Man Niveaux AlÃ©atoires</title>
<style>
    /* Styles de base et du corps */
    body {
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column; /* Organiser verticalement */
        justify-content: center;
        align-items: center;
        height: 100vh;
        background: #0d0d0d;
        font-family: 'Arial', sans-serif;
        color: #fff;
    }
    
    /* Zone d'information (Score/Niveau) */
    #info-bar {
        margin-bottom: 20px;
        font-size: 1.5em;
        text-shadow: 0 0 10px #FFD700;
        color: #FFFF00;
        display: flex;
        gap: 50px;
    }

    /* Conteneur du jeu */
    #game {
        position: relative;
        width: 400px;
        height: 400px;
        background: #000;
        display: grid;
        grid-template-columns: repeat(20, 20px);
        grid-template-rows: repeat(20, 20px);
        border: 4px solid #00FFFF;
        box-shadow: 0 0 20px #00FFFF, inset 0 0 10px #00FFFF;
        box-sizing: content-box; 
    }
    
    /* Murs ðŸ§± - Ã‰pais et stylisÃ©s */
    .wall {
        background: #0000AA;
        border: 1px solid #0000FF;
        box-shadow: inset 0 0 8px #0000FF, 0 0 5px #0000FF;
    }

    /* Points (Pac-Dots) ðŸŸ¡ - Plus brillants */
    .dot-container {
        display: flex;
        justify-content: center;
        align-items: center;
    }
    .dot {
        width: 8px;
        height: 8px;
        background: #FFFF00;
        border-radius: 50%;
        box-shadow: 0 0 10px #FFFF00, 0 0 20px #FFD700;
        animation: pulse 1.5s infinite alternate;
    }

    /* Pac-Man ðŸ˜‹ - La star du jeu */
    #pacman {
        position: absolute;
        width: 18px;
        height: 18px;
        background: #FFD700;
        border-radius: 50%;
        z-index: 10;
        transition: left 0.1s linear, top 0.1s linear, transform 0.1s;
        box-shadow: 0 0 15px #FFD700;
        
        clip-path: polygon(100% 0, 100% 50%, 75% 50%, 100% 100%, 0 100%, 0 0);
        animation: chomp 0.2s infinite step-end;
        transform-origin: center;
    }

    /* Keyframes pour les animations */
    @keyframes chomp {
        0% { clip-path: polygon(100% 0, 100% 50%, 75% 50%, 100% 100%, 0 100%, 0 0); }
        50% { clip-path: circle(50% at 50% 50%); }
    }
    
    @keyframes pulse {
        from { opacity: 0.8; transform: scale(1); }
        to { opacity: 1; transform: scale(1.1); }
    }
</style>
</head>
<body>
<div id="info-bar">
    <div id="level-display">Niveau: 1</div>
    <div id="score-display">Score: 0</div>
</div>
<div id="game"></div>
<div id="pacman"></div>

<script>
    const game = document.getElementById('game');
    const pacman = document.getElementById('pacman');
    const levelDisplay = document.getElementById('level-display');
    const scoreDisplay = document.getElementById('score-display');

    const size = 20; // Taille cellule (20x20px)
    const pacmanSize = 18; // Taille de Pac-Man (18x18px)
    const offset = (size - pacmanSize) / 2; // DÃ©calage pour centrer (1px)
    
    const gridCols = 20;
    const gridRows = 20;
    
    let grid = [];
    let maze = [];
    let pac = {row:1, col:1, direction: 'right'};
    let currentLevel = 1;
    let score = 0;
    let dotsRemaining = 0;

    // --- 1. Logique de Progression de Niveau ---

    /**
     * Fait progresser le jeu au niveau suivant.
     */
    function nextLevel() {
        currentLevel++;
        levelDisplay.textContent = `Niveau: ${currentLevel}`;
        
        // RÃ©initialiser le jeu avec un nouveau labyrinthe
        initGame();
    }

    /**
     * VÃ©rifie si le niveau est terminÃ©.
     */
    function checkWinCondition() {
        if (dotsRemaining === 0) {
            // Un petit dÃ©lai pour que le dernier point disparaisse avant de passer au niveau
            setTimeout(nextLevel, 500);
        }
    }


    // --- 2. GÃ©nÃ©ration AlÃ©atoire du Labyrinthe (DFS) ---
    function createEmptyMaze() {
        const tempMaze = [];
        for (let r = 0; r < gridRows; r++) {
            tempMaze[r] = [];
            for (let c = 0; c < gridCols; c++) {
                tempMaze[r][c] = 1; // 1 = Mur
            }
        }
        return tempMaze;
    }

    function generateRandomMaze() {
        maze = createEmptyMaze();
        const stack = [];
        const startR = 1;
        const startC = 1;
        
        stack.push({ r: startR, c: startC });
        maze[startR][startC] = 0; // 0 = Chemin

        while (stack.length > 0) {
            const current = stack.pop();
            const { r, c } = current;
            
            const directions = [
                { dr: -2, dc: 0 }, { dr: 2, dc: 0 }, 
                { dr: 0, dc: -2 }, { dr: 0, dc: 2 }
            ];
            
            directions.sort(() => Math.random() - 0.5);

            for (const dir of directions) {
                const nextR = r + dir.dr;
                const nextC = c + dir.dc;

                if (nextR > 0 && nextR < gridRows - 1 && nextC > 0 && nextC < gridCols - 1 && maze[nextR][nextC] === 1) {
                    const wallR = r + dir.dr / 2;
                    const wallC = c + dir.dc / 2;
                    maze[wallR][wallC] = 0;
                    maze[nextR][nextC] = 0;
                    
                    stack.push(current); 
                    stack.push({ r: nextR, c: nextC });
                    break;
                }
            }
        }
    }
    
    /**
     * Dessine le labyrinthe et compte les points.
     */
    function drawMaze() {
        game.innerHTML = '';
        grid.length = 0;
        dotsRemaining = 0;

        // Ajouter les points (2) dans les chemins (0)
        for(let r=0;r<gridRows;r++){
            for(let c=0;c<gridCols;c++){
                if(maze[r][c] === 0){
                    maze[r][c] = 2; // 2 = Point
                    dotsRemaining++;
                }
            }
        }
        
        // Retirer le point de la case de dÃ©part de Pac-Man
        maze[pac.row][pac.col] = 0;
        dotsRemaining--;

        // Dessin dans le DOM
        for(let r=0;r<gridRows;r++){
            for(let c=0;c<gridCols;c++){
                const cell = document.createElement('div');
                if(maze[r][c]===1) cell.className='wall';
                else if(maze[r][c]===2){
                    cell.className='dot-container';
                    const dot = document.createElement('div');
                    dot.className='dot';
                    cell.appendChild(dot);
                }
                game.appendChild(cell);
                grid.push({row:r,col:c,type:maze[r][c],el:cell});
            }
        }
    }

    // --- 3. ContrÃ´les et Mouvement (avec Mise Ã  Jour de Score) ---

    function updatePacmanPosition() {
        // Le calcul pour centrer le 18x18 dans le 20x20
        pacman.style.left = (pac.col * size + offset) + 'px'; 
        pacman.style.top = (pac.row * size + offset) + 'px';
    }

    function setPacmanRotation(dir) {
        let rotation = 0;
        if (dir === 'right') rotation = 0;
        else if (dir === 'down') rotation = 90;
        else if (dir === 'left') rotation = 180;
        else if (dir === 'up') rotation = 270;

        pacman.style.transform = `rotate(${rotation}deg)`;
    }
    
    // Pour ne pas ajouter un nouvel Ã©couteur de touche Ã  chaque niveau
    let isListenerActive = false; 

    function handleKeyDown(e) {
        let newRow = pac.row;
        let newCol = pac.col;
        let newDir = pac.direction;

        if(e.key==='ArrowUp'){ newRow--; newDir='up'; }
        else if(e.key==='ArrowDown'){ newRow++; newDir='down'; }
        else if(e.key==='ArrowLeft'){ newCol--; newDir='left'; }
        else if(e.key==='ArrowRight'){ newCol++; newDir='right'; }

        if (newDir !== pac.direction) {
            pac.direction = newDir;
            setPacmanRotation(pac.direction);
        }

        // VÃ©rifier mur et limites
        if(newRow>=0 && newRow<gridRows && newCol>=0 && newCol<gridCols && maze[newRow][newCol]!==1){
            
            // DÃ©placer Pac-Man
            pac.row=newRow; pac.col=newCol;
            updatePacmanPosition();

            // Manger un point
            const idx = newRow*gridCols+newCol;
            if(grid[idx].type===2){
                // Mise Ã  jour des scores et dÃ©compte
                score += 10; 
                dotsRemaining--;
                scoreDisplay.textContent = `Score: ${score}`;

                grid[idx].type=0; // Marquer la case comme vide
                maze[newRow][newCol] = 0; // Mettre Ã  jour la matrice
                grid[idx].el.innerHTML=''; // enlever dot visuellement

                checkWinCondition();
            }
        }
    }

    // --- 4. Fonction d'Initialisation Globale ---

    function initGame() {
        // 1. GÃ©nÃ©rer le nouveau labyrinthe et le dessiner
        generateRandomMaze();
        drawMaze();

        // 2. RÃ©initialiser la position et l'apparence de Pac-Man
        pac.row = 1;
        pac.col = 1;
        pac.direction = 'right';
        updatePacmanPosition();
        setPacmanRotation(pac.direction);
        
        // 3. Activer les Ã©couteurs si ce n'est pas dÃ©jÃ  fait
        if (!isListenerActive) {
            document.addEventListener('keydown', handleKeyDown);
            isListenerActive = true;
        }
    }

    // DÃ©marrer le jeu au niveau 1
    initGame(); 
</script>
</body>
</html>
